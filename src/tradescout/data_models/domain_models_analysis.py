"""
TradeScout Analysis Models

Models for trading analysis, suggestions, and performance tracking.
These models handle the business logic of momentum trading.
"""

from dataclasses import dataclass, field
from datetime import datetime
from decimal import Decimal
from enum import Enum
from typing import Dict, List, Optional, Set
import uuid

from .domain_models_core import Asset


class TradeSide(Enum):
    """Trade direction"""

    LONG = "long"
    SHORT = "short"


class TradeStatus(Enum):
    """Trade execution status"""

    SUGGESTED = "suggested"
    EXECUTED = "executed"
    CANCELLED = "cancelled"
    EXPIRED = "expired"


class ConfidenceLevel(Enum):
    """Confidence levels for trade suggestions"""

    LOW = "low"  # 50-70%
    MEDIUM = "medium"  # 70-85%
    HIGH = "high"  # 85-95%
    VERY_HIGH = "very_high"  # 95%+


class GapType(Enum):
    """Gap classification types based on academic research"""

    COMMON = "common"  # <1.5% size, noise trading
    BREAKAWAY = "breakaway"  # 2-5% size, trend initiation
    CONTINUATION = "continuation"  # 2-7% size, trend acceleration
    EXHAUSTION = "exhaustion"  # >5% size, trend termination
    UNKNOWN = "unknown"  # Insufficient data to classify


class GapStrength(Enum):
    """Gap strength assessment"""

    WEAK = "weak"  # Low probability setup
    MODERATE = "moderate"  # Decent probability setup
    STRONG = "strong"  # High probability setup
    VERY_STRONG = "very_strong"  # Exceptional setup


class GapRiskLevel(Enum):
    """Risk assessment for gap trades"""

    LOW = "low"  # High-confidence, well-defined setups
    MEDIUM = "medium"  # Standard gap trading risk
    HIGH = "high"  # Higher uncertainty or volatility
    EXTREME = "extreme"  # Avoid - manipulation/thin volume risk


@dataclass
class TechnicalIndicators:
    """Technical analysis indicators for an asset"""

    asset: Asset
    timestamp: datetime
    timeframe: str  # "1m", "5m", "1h", "1d", etc.

    # Price indicators
    sma_20: Optional[Decimal] = None
    sma_50: Optional[Decimal] = None
    ema_12: Optional[Decimal] = None
    ema_26: Optional[Decimal] = None

    # Momentum indicators
    rsi: Optional[Decimal] = None
    macd: Optional[Decimal] = None
    macd_signal: Optional[Decimal] = None
    macd_histogram: Optional[Decimal] = None

    # Volume indicators
    volume_sma: Optional[Decimal] = None
    volume_ratio: Optional[Decimal] = None

    # Volatility
    bollinger_upper: Optional[Decimal] = None
    bollinger_lower: Optional[Decimal] = None
    atr: Optional[Decimal] = None

    @property
    def is_oversold(self) -> bool:
        """Check if RSI indicates oversold conditions"""
        return self.rsi is not None and self.rsi < 30

    @property
    def is_overbought(self) -> bool:
        """Check if RSI indicates overbought conditions"""
        return self.rsi is not None and self.rsi > 70

    @property
    def is_macd_bullish(self) -> bool:
        """Check if MACD shows bullish signal"""
        return (
            self.macd is not None
            and self.macd_signal is not None
            and self.macd > self.macd_signal
        )


@dataclass
class TradeSuggestion:
    """Trade suggestion generated by analysis engine"""

    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    timestamp: datetime = field(default_factory=datetime.now)

    # Core trade details
    asset: Asset = None
    side: TradeSide = TradeSide.LONG
    confidence: ConfidenceLevel = ConfidenceLevel.MEDIUM
    confidence_score: Decimal = Decimal(0)  # 0.0 to 1.0

    # Entry and exit points
    suggested_entry: Decimal = Decimal(0)
    stop_loss: Decimal = Decimal(0)
    take_profit_1: Decimal = Decimal(0)
    take_profit_2: Optional[Decimal] = None

    # Risk management
    position_size_percent: Decimal = Decimal(2)  # % of portfolio
    max_hold_time_hours: int = 4
    risk_reward_ratio: Decimal = Decimal(0)

    # Analysis rationale
    rationale: str = ""
    supporting_factors: List[str] = field(default_factory=list)
    risk_factors: List[str] = field(default_factory=list)

    # Market context
    gap_percent: Optional[Decimal] = None
    volume_surge: bool = False
    news_catalyst: bool = False
    technical_setup: bool = False

    # Performance tracking
    status: TradeStatus = TradeStatus.SUGGESTED
    max_profit_reached: Optional[Decimal] = None
    max_loss_reached: Optional[Decimal] = None
    actual_exit_price: Optional[Decimal] = None
    actual_exit_time: Optional[datetime] = None

    @property
    def risk_amount(self) -> Decimal:
        """Calculate risk amount per share"""
        return abs(self.suggested_entry - self.stop_loss)

    @property
    def profit_potential_1(self) -> Decimal:
        """Calculate profit potential to first target"""
        return abs(self.take_profit_1 - self.suggested_entry)

    @property
    def is_valid_risk_reward(self) -> bool:
        """Check if risk/reward ratio is acceptable (>1.0)"""
        return self.risk_reward_ratio >= 1.0


@dataclass
class ActualTrade:
    """Actual trade executed by user"""

    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    suggestion_id: Optional[str] = None  # Link to suggestion if followed

    # Trade execution
    asset: Asset = None
    side: TradeSide = TradeSide.LONG
    entry_price: Decimal = Decimal(0)
    entry_time: datetime = field(default_factory=datetime.now)
    shares: int = 0

    # Exit details
    exit_price: Optional[Decimal] = None
    exit_time: Optional[datetime] = None
    exit_reason: str = ""  # "target", "stop", "manual", "time"

    # Performance
    realized_pnl: Optional[Decimal] = None
    unrealized_pnl: Optional[Decimal] = None
    hold_time_minutes: Optional[int] = None

    # User notes
    notes: str = ""
    lessons_learned: str = ""

    @property
    def is_open(self) -> bool:
        """Check if trade is still open"""
        return self.exit_price is None

    @property
    def is_profitable(self) -> bool:
        """Check if trade was/is profitable"""
        if self.realized_pnl:
            return self.realized_pnl > 0
        return False


@dataclass
class PerformanceMetrics:
    """Performance tracking for suggestions and actual trades"""

    period_start: datetime
    period_end: datetime

    # Suggestion performance
    total_suggestions: int = 0
    suggestions_followed: int = 0
    winning_suggestions: int = 0
    losing_suggestions: int = 0
    suggestion_win_rate: Decimal = Decimal(0)
    avg_suggestion_return: Decimal = Decimal(0)

    # Actual trade performance
    total_trades: int = 0
    winning_trades: int = 0
    losing_trades: int = 0
    trade_win_rate: Decimal = Decimal(0)
    total_pnl: Decimal = Decimal(0)
    avg_trade_return: Decimal = Decimal(0)
    best_trade: Decimal = Decimal(0)
    worst_trade: Decimal = Decimal(0)

    # Risk metrics
    max_drawdown: Decimal = Decimal(0)
    sharpe_ratio: Optional[Decimal] = None
    profit_factor: Optional[Decimal] = None

    # Time analysis
    avg_hold_time_minutes: Optional[Decimal] = None


@dataclass
class MarketEvent:
    """Significant market event or catalyst"""

    timestamp: datetime
    event_type: str  # "earnings", "fda_approval", "merger", etc.
    asset: Asset
    title: str
    description: str
    expected_impact: str  # "bullish", "bearish", "neutral"

    # Optional fields with defaults
    id: str = field(default_factory=lambda: str(uuid.uuid4()))

    # Timing
    scheduled_time: Optional[datetime] = None
    is_before_market_open: bool = False
    is_after_market_close: bool = False

    # Impact assessment
    historical_impact_percent: Optional[Decimal] = None
    volume_impact_multiplier: Optional[Decimal] = None


@dataclass
class GapClassification:
    """Gap type classification with confidence metrics"""

    asset: Asset
    timestamp: datetime
    gap_type: GapType
    confidence_score: Decimal  # 0.0 to 1.0

    # Gap characteristics
    gap_percent: Decimal
    gap_amount: Decimal
    size_category: str  # "small", "medium", "large", "extreme"

    # Research-based probabilities
    expected_fill_probability: Decimal
    expected_continuation_probability: Decimal

    # Classification context
    classification_reason: str = ""
    supporting_factors: List[str] = field(default_factory=list)
    warning_flags: List[str] = field(default_factory=list)

    @property
    def is_tradeable(self) -> bool:
        """Quick check if gap meets minimum tradeable criteria"""
        return (
            self.gap_type != GapType.COMMON
            and self.confidence_score >= Decimal("0.6")
            and abs(self.gap_percent) >= Decimal("2.0")
        )

    @property
    def risk_level(self) -> GapRiskLevel:
        """Assess risk level based on gap characteristics"""
        if self.gap_type == GapType.CONTINUATION and self.confidence_score >= Decimal("0.8"):
            return GapRiskLevel.LOW
        elif self.gap_type == GapType.BREAKAWAY and self.confidence_score >= Decimal("0.7"):
            return GapRiskLevel.MEDIUM
        elif self.gap_type == GapType.EXHAUSTION:
            return GapRiskLevel.HIGH
        else:
            return GapRiskLevel.EXTREME


@dataclass
class GapStrengthMetrics:
    """Comprehensive gap strength assessment"""

    asset: Asset
    timestamp: datetime

    # Volume confirmation
    volume_ratio: Decimal  # Current vs average volume
    volume_confirmation: bool
    premarket_volume_surge: bool

    # Technical context
    technical_breakout: bool
    trend_alignment: bool
    support_resistance_break: bool

    # Catalyst assessment
    news_catalyst_present: bool
    catalyst_quality_score: Decimal  # 0.0 to 1.0
    
    # Market context
    market_alignment: bool
    sector_momentum: bool
    
    # Composite strength
    overall_strength: GapStrength
    strength_score: Decimal  # 0.0 to 1.0
    
    # Optional string fields with defaults (must come last)
    catalyst_type: str = ""  # "earnings", "fda", "merger", etc.
    overall_market_trend: str = ""  # "bullish", "bearish", "neutral"

    @property
    def has_strong_volume(self) -> bool:
        """Check if volume supports the gap"""
        return self.volume_ratio >= Decimal("2.0") and self.volume_confirmation

    @property
    def has_catalyst_support(self) -> bool:
        """Check if news catalyst supports the gap"""
        return self.news_catalyst_present and self.catalyst_quality_score >= Decimal("0.6")


@dataclass
class GapTradabilityAssessment:
    """Final assessment of gap trading opportunity"""

    asset: Asset
    timestamp: datetime
    gap_classification: GapClassification
    strength_metrics: GapStrengthMetrics

    # Trading assessment
    is_tradeable: bool
    recommended_strategy: str  # "momentum", "reversal", "avoid"
    recommended_side: TradeSide
    risk_level: GapRiskLevel

    # Timing recommendations
    optimal_entry_timing: str  # "immediate", "1hour_rule", "avoid"
    suggested_hold_time: str  # "intraday", "swing", "position"
    max_hold_hours: int = 4

    # Risk management
    suggested_position_size_percent: Decimal = Decimal("1.0")
    stop_loss_percent: Decimal = Decimal("2.0")
    take_profit_percent: Decimal = Decimal("3.0")

    # Rationale
    trading_rationale: str = ""
    key_success_factors: List[str] = field(default_factory=list)
    primary_risks: List[str] = field(default_factory=list)

    @property
    def risk_reward_ratio(self) -> Decimal:
        """Calculate expected risk/reward ratio"""
        if self.stop_loss_percent > 0:
            return self.take_profit_percent / self.stop_loss_percent
        return Decimal("0")

    @property
    def trade_quality_score(self) -> Decimal:
        """Overall trade quality score (0.0 to 1.0)"""
        if not self.is_tradeable:
            return Decimal("0")

        score = (
            self.gap_classification.confidence_score * Decimal("0.4") +
            self.strength_metrics.strength_score * Decimal("0.4") +
            (Decimal("1.0") if self.risk_level in [GapRiskLevel.LOW, GapRiskLevel.MEDIUM] else Decimal("0.2")) * Decimal("0.2")
        )
        return min(Decimal("1.0"), score)
